= Stagg Specification

== Introduction

== Basic Types



== Collection

*Collection of named objects, possibly with one or more common axis.*

[%hardbreaks]
•{nbsp} *objects*: str → <<Histogram>> or <<Ntuple>> or <<ParameterizedFunction>> or <<BinnedEvaluatedFunction>> or <<Collection>> +
_(default: null/empty)_
•{nbsp} *axis*: list of <<Axis>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_

*Details:*

A simple reason for using a collection would be to gather many objects into a convenient package that can be transmitted as a group. For this purpose, *axis* should be empty. Note that objects (such as histograms, functions, and ntuples) do not have names on their own; names are just keys in the *objects* property, used solely for lookup.

Assigning an *axis* to a collection, rather than individually to all objects it contains, is to avoid duplication when defining similarly binned data. As an example of the latter, consider histograms three `h1`, `h2`, `h3` with two sets of cuts applied, `"signal"` and `"control"` (six histograms total).

    Collection({"h1": h1, "h2": h2, "h3": h3},
               axis=[Axis(PredicateBinning("signal"), PredicateBinning("control"))])

This predicate axis (defined by if-then rules when the histograms were filled) is prepended onto the axes defined in each histogram separately. For instance, if `h1` had one regular axis and `h2` had two irregular axes, the `"h1"` in this collection has two axes: predicate, then regular, and the `"h2"` in this collection has three axes: predicate, then irregular, then irregular. This way, hundreds or thousands of histograms with similar binning can be defined in a contiguous block without repetition of axis definition (good for efficiency and avoiding copy-paste errors).

To subdivide one set of objects and not another, or to subdivide two sets of objects differently, put collections inside of collections. In the following example, `h1` and `h2` are subdivided but `h3` is not.

    Collection({"by region":
                    Collection({"h1": h1, "h2": h2},
                    axis=[Axis(PredicateBinning("signal"), PredicateBinning("control"))]),
                "h3": h3})

Similarly, regions can be subdivided into subregions, and other binning types may be used.

The buffers for each object must be the appropriate size to represent all of its axes, including any inherited from collections. (For example, a counts buffer appropriate for a standalone `h1` would not fit an `"h1"` with prepended axes due to being in a collection.)

The *title*, *metadata*, *decoration*, and *script* properties have no semantic constraints.

== Histogram

*Histogram of a distribution, defined by a (possibly weighted) count of observations in each bin of an n-dimensional space.*

[%hardbreaks]
•{nbsp} *axis*: list of <<Axis>> with length in [1, ∞) _(required)_
•{nbsp} *counts*: <<UnweightedCounts>> or <<WeightedCounts>> _(required)_
•{nbsp} *profile*: list of <<Profile>> _(default: null/empty)_
•{nbsp} *axis_covariances*: list of <<Covariance>> _(default: null/empty)_
•{nbsp} *profile_covariances*: list of <<Covariance>> _(default: null/empty)_
•{nbsp} *functions*: str → <<ParameterizedFunction>> or <<EvaluatedFunction>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_
The *xindex* and *yindex* of each Covariance in *axis_covariances* must be in [0, number of *axis*) and be unique pairs. +
The *xindex* and *yindex* of each Covariance in *profile_covariances* must be in [0, number of *profile*) and be unique pairs.

*Details:*

The space is subdivided by an n-dimensional *axis*. As described in <<Collection>>, nesting a histogram within a collection prepends the collection's *axis*. The number of <<Axis>> objects is not necessarily the dimensionality of the space; some binnings, such as <<HexagonalBinning>>, define more than one dimension (though most do not).

The *counts* are separate from the *axis*, though the buffers providing counts must be exactly the right size to fit the n-dimensional binning (including axes inherited from a <<Collection>>).

Histograms with only *axis* and *counts* are pure distributions, histograms in the conventional sense. All other properties provide additional information about the dataset.

Any *profiles* summarize dependent variables (where the *axis* defines independent variables). For instance, a profile can represent mean and standard deviation `y` values for an axis binned in `x`.

The <<Axis>> and <<Profile>> classes internally define summary statistics, such as the mean or median of that axis. However, those <<Statistics>> objects cannot describe correlations among axes. If this information is available, it can be expressed in *axis_covariances* or *profile_covariances*.

Any *functions* associated with the histogram, such as fit results, may be attached directly to the histogram object with names. If an <<EvaluatedFunction>> is included, its binning is derived from the histogram's full *axis* (including any *axis* inherited from a <<Collection>>).

The *title*, *metadata*, *decoration*, and *script* properties have no semantic constraints.

*See also:*

   * <<BinnedEvaluatedFunction>>: for lookup functions that aren't statistical distributions.

== Axis

*Axis of a histogram or binned function representing one or more binned dimensions.*

[%hardbreaks]
•{nbsp} *binning*: <<IntegerBinning>> or <<RegularBinning>> or <<HexagonalBinning>> or <<EdgesBinning>> or <<IrregularBinning>> or <<CategoryBinning>> or <<SparseRegularBinning>> or <<FractionBinning>> or <<PredicateBinning>> or <<VariationBinning>> +
_(default: null)_
•{nbsp} *expression*: str _(default: null)_
•{nbsp} *statistics*: list of <<Statistics>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
The *statistics* must be empty or have a length equal to the number of dimensions in the *binning* (no binning is one-dimensional).

*Details:*

The dimension or dimensions are subdivided by the *binning* property; all other properties provide additional information.

If the axis represents a computed *expression*, it may be encoded here as a string. The *title* is a human-readable description.

A <<Statistics>> object (one per dimension) summarizes the data separately from the histogram counts. For instance, it may contain the mean and standard deviation of all data along a dimension, which is more accurate than a mean and standard deviation derived from the counts.

The *expression*, *title*, *metadata*, and *decoration* properties have no semantic constraints.

== IntegerBinning

*Splits a one-dimensional axis into a contiguous set of integer-valued bins.*

[%hardbreaks]
•{nbsp} *min*: int in (‒∞, ∞) _(required)_
•{nbsp} *max*: int in (‒∞, ∞) _(required)_
•{nbsp} *loc_underflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_
The *min* must be strictly less than the *max*. +
The *loc_underflow* and *loc_overflow* must not be equal unless they are `nonexistent`.

*Details:*

This binning is intended for one-dimensional, integer-valued data in a compact range. The *min* and *max* values are both inclusive, so the number of bins is `+1 + max - min+`.

If *loc_underflow* and *loc_overflow* are `nonexistent`, then there are no slots in the <<Histogram>> counts or <<BinnedEvaluatedFunction>> values for underflow or overflow. If they are `below`, then their slots precede the normal bins, if `above`, then their slots follow the normal bins, and their order is in sequence: `below3`, `below2`, `below1`, (normal bins), `above1`, `above2`, `above3`.

== RegularBinning

*Splits a one-dimensional axis into an ordered, abutting set of equal-sized real intervals.*

[%hardbreaks]
•{nbsp} *num*: int in [1, ∞) _(required)_
•{nbsp} *interval*: <<RealInterval>> _(required)_
•{nbsp} *overflow*: <<RealOverflow>> _(default: null)_
•{nbsp} *circular*: bool _(default: false)_
The *interval.low* and *interval.high* limits must both be finite. +
The *interval.low_inclusive* and *interval.high_inclusive* cannot both be true. (They can both be false, which allows for infinitesimal gaps between bins.)

*Details:*

This binning is intended for one-dimensional, real-valued data in a compact range. The limits of this range are specified in a single <<RealInterval>>, and the number of subdivisions is *num*.

The existence and positions of any underflow, overflow, and nanflow bins, as well as how non-finite values were handled during filling, are contained in the <<RealOverflow>>.

If the binning is *circular*, then it represents a finite segment in which *interval.low* is topologically identified with *interval.high*. This could be used to convert [‒π, π) intervals into [0, 2π) intervals, for instance.

*See also:*

   * <<RegularBinning>>: for ordered, equal-sized, abutting real intervals.
   * <<EdgesBinning>>: for ordered, any-sized, abutting real intervals.
   * <<IrregularBinning>>: for unordered, any-sized real intervals (that may even overlap).
   * <<SparseRegularBinning>>: for unordered, equal-sized real intervals aligned to a regular grid, but only need to be defined if the bin content is not zero.

== RealInterval

*Represents a real interval with inclusive (closed) or exclusive (open) endpoints.*

[%hardbreaks]
•{nbsp} *low*: float in [‒∞, ∞] _(required)_
•{nbsp} *high*: float in [‒∞, ∞] _(required)_
•{nbsp} *low_inclusive*: bool _(default: true)_
•{nbsp} *high_inclusive*: bool _(default: false)_
The *low* limit must be less than or equal to the *high* limit. +
The *low* limit may only be equal to the *high* limit if at least one endpoint is inclusive (*low_inclusive* or *high_inclusive* is true). Such an interval would represent a single real value.

*Details:*

The position and size of the real interval is defined by *low* and *high*, and each endpoint is inclusive (closed) if *low_inclusive* or *high_inclusive*, respectively, is true. Otherwise, the endpoint is exclusive (open).

A single interval defines a <<RegularBinning>> and a set of intervals defines an <<IrregularBinning>>.

== RealOverflow

*Underflow, overflow, and nanflow configuration for one-dimensional, real-valued data.*

[%hardbreaks]
•{nbsp} *loc_underflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_
•{nbsp} *loc_nanflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_
•{nbsp} *minf_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
_(default: `+RealOverflow.in_underflow+`)_
•{nbsp} *pinf_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
_(default: `+RealOverflow.in_overflow+`)_
•{nbsp} *nan_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
_(default: `+RealOverflow.in_nanflow+`)_
The *loc_underflow*, *loc_overflow*, and *loc_nanflow* must not be equal unless they are `nonexistent`. +
The *minf_mapping* (‒∞ mapping) can only be `missing`, `in_underflow`, or `in_nanflow`, not `in_overflow`. +
The *pinf_mapping* (+∞ mapping) can only be `missing`, `in_overflow`, or `in_nanflow`, not `in_underflow`.

*Details:*

If *loc_underflow*, *loc_overflow*, and *loc_nanflow* are `nonexistent`, then there are no slots in the <<Histogram>> counts or <<BinnedEvaluatedFunction>> values for underflow, overflow, or nanflow. Underflow represents values smaller than the lower limit of the binning, overflow represents values larger than the upper limit of the binning, and nanflow represents floating-point values that are `nan` (not a number). With the normal bins, underflow, overflow, and nanflow, every possible input value corresponds to some bin.

If any of the *loc_underflow*, *loc_overflow*, and *loc_nanflow* are `below`, then their slots precede the normal bins, if `above`, then their slots follow the normal bins, and their order is in sequence: `below3`, `below2`, `below1`, (normal bins), `above1`, `above2`, `above3`. It is possible to represent a histogram counts buffer with the three special bins in any position relative to the normal bins.

The *minf_mapping* specifies whether ‒∞ values were ignored when the histogram was filled (`missing`), are in the underflow bin (`in_underflow`) or are in the nanflow bin (`in_nanflow`). The *pinf_mapping* specifies whether +∞ values were ignored when the histogram was filled (`missing`), are in the overflow bin (`in_overflow`) or are in the nanflow bin (`in_nanflow`). Thus, it would be possible to represent a histogram that was filled with finite underflow/overflow bins and a generic bin for all three non-finite floating point states.

== HexagonalBinning

*Splits a two-dimensional axis into a tiling of equal-sized hexagons.*

[%hardbreaks]
•{nbsp} *qmin*: int in (‒∞, ∞) _(required)_
•{nbsp} *qmax*: int in (‒∞, ∞) _(required)_
•{nbsp} *rmin*: int in (‒∞, ∞) _(required)_
•{nbsp} *rmax*: int in (‒∞, ∞) _(required)_
•{nbsp} *coordinates*: one of {`+HexagonalBinning.offset+`, `+HexagonalBinning.doubled_offset+`, `+HexagonalBinning.cube_xy+`, `+HexagonalBinning.cube_yz+`, `+HexagonalBinning.cube_xz+`} +
_(default: `+HexagonalBinning.offset+`)_
•{nbsp} *xorigin*: float in (‒∞, ∞) _(default: 0.0)_
•{nbsp} *yorigin*: float in (‒∞, ∞) _(default: 0.0)_
•{nbsp} *qangle*: float in [‒π/2, π/2] _(default: 0.0)_
•{nbsp} *qoverflow*: <<RealOverflow>> _(default: null)_
•{nbsp} *roverflow*: <<RealOverflow>> _(default: null)_
The *qmin* must be strictly less than the *qmax*. +
The *rmin* must be strictly less than the *rmax*.

*Details:*

This binning is intended for two-dimensional, real-valued data in a compact region. Hexagons tile a two-dimensional plane, just as rectangles do, but whereas a rectangular tiling can be represented by two <<RegularBinning>> axes, hexagonal binning requires a special binning. Some advantages of hexagonal binning are https://www.meccanismocomplesso.org/hexagonal-binning[described here].

As with any other binning, integer-valued indexes in the <<Histogram>> counts or <<BinnedEvaluatedFunction>> values are mapped to values in the data space. However, rather than mapping a single integer slot position to an integer, real interval, or categorical data value, two integers from a rectangular integer grid are mapped to hexagonal tiles. The integers are labeled `q` and `r`, with `q` values between *qmin* and *qmax* (inclusive) and `r` values between *rmin* and *rmax* (inclusive). The total number of bins is `(1 + qmax - qmin)*(1 + rmax - rmin)`. Data coordinates are labeled `x` and `y`.

There are several different schemes for mapping integer rectangles to hexagonal tiles; we use the ones https://www.redblobgames.com/grids/hexagons[defined here]: `offset`, `doubled_offset`, `cube_xy`, `cube_yz`, `cube_xz`, specified by the *coordinates* property. The center of the `q = 0, r = 0` tile is at *xorigin*, *yorigin*.

In "`pointy topped`" coordinates, *qangle* is zero if increasing `q` is collinear with increasing `x`, and this angle ranges from ‒π/2, if increasing `q` is collinear with decreasing `y`, to π/2, if increasing `q` is collinear with increasing `y`.

A roughly but not exactly rectangular region of `x` and `y` fall within a slot in `q` and `r`. Overflows, underflows, and nanflows, converted to floating-point `q` and `r`, are represented by overflow, underflow, and nanflow bins in *qoverflow* and *roverflow*. Note that the total number of bins is strictly multiplicative (as it would be for a rectangular with two <<RegularBinning>> axes): the total number of bins is the number of normal `q` bins plus any overflows times the number of normal `r` bins plus any overflows. That is, all `r` bins are represented for each `q` bin, even overflow `q` bins.

== EdgesBinning

*Splits a one-dimensional axis into an ordered, abutting set of any-sized real intervals.*

[%hardbreaks]
•{nbsp} *edges*: list of float with length in [1, ∞) _(required)_
•{nbsp} *overflow*: <<RealOverflow>> _(default: null)_
•{nbsp} *low_inclusive*: bool _(default: true)_
•{nbsp} *high_inclusive*: bool _(default: false)_
•{nbsp} *circular*: bool _(default: false)_
All *edges* must be finite and strictly increasing. +
An *edges* of length 1 is only allowed if *overflow* is non-null with at least one underflow, overflow, or nanflow bin. +
The *low_inclusive* and *high_inclusive* cannot both be true. (They can both be false, which allows for infinitesimal gaps between bins.)

*Details:*

This binning is intended for one-dimensional, real-valued data in a compact range. The limits of this range and the size of each bin are defined by *edges*, which are the edges _between_ the bins. Since they are edges between bins, the number of non-overflow bins is `len(edges) - 1`. The degenerate case of exactly one edge is only allowed if there are any underflow, overflow, or nanflow bins.

If *low_inclusive* is true, then all intervals between pairs of edges include the low edge. If *high_inclusive* is true, then all intervals between pairs of edges include the high edge.

If the binning is *circular*, then it represents a finite segment in which *interval.low* is topologically identified with *interval.high*. This could be used to convert [‒π, π) intervals into [0, 2π) intervals, for instance.

*See also:*

   * <<RegularBinning>>: for ordered, equal-sized, abutting real intervals.
   * <<EdgesBinning>>: for ordered, any-sized, abutting real intervals.
   * <<IrregularBinning>>: for unordered, any-sized real intervals (that may even overlap).
   * <<SparseRegularBinning>>: for unordered, equal-sized real intervals aligned to a regular grid, but only need to be defined if the bin content is not zero.

== IrregularBinning

**

[%hardbreaks]
•{nbsp} *intervals*: list of <<RealInterval>> with length in [1, ∞) _(required)_
•{nbsp} *overflow*: <<RealOverflow>> _(default: null)_
•{nbsp} *overlapping_fill*: one of {`+IrregularBinning.undefined+`, `+IrregularBinning.all+`, `+IrregularBinning.first+`, `+IrregularBinning.last+`} +
_(default: `+IrregularBinning.undefined+`)_

*Details:*

*See also:*

   * <<RegularBinning>>: for ordered, equal-sized, abutting real intervals.
   * <<EdgesBinning>>: for ordered, any-sized, abutting real intervals.
   * <<IrregularBinning>>: for unordered, any-sized real intervals (that may even overlap).
   * <<SparseRegularBinning>>: for unordered, equal-sized real intervals aligned to a regular grid, but only need to be defined if the bin content is not zero.

== CategoryBinning

**

[%hardbreaks]
•{nbsp} *categories*: list of str _(required)_
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
_(default: `+BinLocation.nonexistent+`)_

*Details:*



== SparseRegularBinning

**

[%hardbreaks]
•{nbsp} *bins*: list of int _(required)_
•{nbsp} *bin_width*: float in (0, ∞] _(required)_
•{nbsp} *origin*: float in [‒∞, ∞] _(default: 0.0)_
•{nbsp} *overflow*: <<RealOverflow>> _(default: null)_
•{nbsp} *low_inclusive*: bool _(default: true)_
•{nbsp} *high_inclusive*: bool _(default: false)_
•{nbsp} *minbin*: int in [‒2⁶³, 2⁶³ ‒ 1] _(default: ‒2⁶³)_
•{nbsp} *maxbin*: int in [‒2⁶³, 2⁶³ ‒ 1] _(default: 2⁶³ ‒ 1)_

*Details:*

*See also:*

   * <<RegularBinning>>: for ordered, equal-sized, abutting real intervals.
   * <<EdgesBinning>>: for ordered, any-sized, abutting real intervals.
   * <<IrregularBinning>>: for unordered, any-sized real intervals (that may even overlap).
   * <<SparseRegularBinning>>: for unordered, equal-sized real intervals aligned to a regular grid, but only need to be defined if the bin content is not zero.

== FractionBinning

**

[%hardbreaks]
•{nbsp} *layout*: one of {`+FractionBinning.passall+`, `+FractionBinning.failall+`, `+FractionBinning.passfail+`} +
_(default: `+FractionBinning.passall+`)_
•{nbsp} *layout_reversed*: bool _(default: false)_
•{nbsp} *error_method*: one of {`+FractionBinning.undefined+`, `+FractionBinning.normal+`, `+FractionBinning.clopper_pearson+`, `+FractionBinning.wilson+`, `+FractionBinning.agresti_coull+`, `+FractionBinning.feldman_cousins+`, `+FractionBinning.jeffrey+`, `+FractionBinning.bayesian_uniform+`} +
_(default: `+FractionBinning.undefined+`)_

*Details:*



== PredicateBinning

**

[%hardbreaks]
•{nbsp} *predicates*: list of str with length in [1, ∞) _(required)_
•{nbsp} *overlapping_fill*: one of {`+IrregularBinning.undefined+`, `+IrregularBinning.all+`, `+IrregularBinning.first+`, `+IrregularBinning.last+`} +
_(default: `+IrregularBinning.undefined+`)_

*Details:*



== VariationBinning

**

[%hardbreaks]
•{nbsp} *variations*: list of <<Variation>> with length in [1, ∞) _(required)_

*Details:*



== Variation

**

[%hardbreaks]
•{nbsp} *assignments*: list of <<Assignment>> _(required)_
•{nbsp} *systematic*: list of float _(default: null/empty)_
•{nbsp} *category_systematic*: list of str _(default: null/empty)_

*Details:*



== Assignment

**

[%hardbreaks]
•{nbsp} *identifier*: unique str _(required)_
•{nbsp} *expression*: str _(required)_

*Details:*



== UnweightedCounts

**

[%hardbreaks]
•{nbsp} *counts*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_

*Details:*



== WeightedCounts

**

[%hardbreaks]
•{nbsp} *sumw*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *sumw2*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(default: null)_
•{nbsp} *unweighted*: <<UnweightedCounts>> _(default: null)_

*Details:*



== InterpretedInlineBuffer

**

[%hardbreaks]
•{nbsp} *buffer*: buffer _(required)_
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
_(default: null/empty)_
•{nbsp} *postfilter_slice*: slice (start:stop:step) _(default: null)_
•{nbsp} *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`} +
_(default: `+Interpretation.none+`)_
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
_(default: `+Interpretation.little_endian+`)_
•{nbsp} *dimension_order*: one of {`+InterpretedBuffer.c_order+`, `+InterpretedBuffer.fortran+`} +
_(default: `+InterpretedBuffer.c_order+`)_

*Details:*



== InterpretedInlineInt64Buffer

**

[%hardbreaks]
•{nbsp} *buffer*: buffer _(required)_

*Details:*



== InterpretedInlineFloat64Buffer

**

[%hardbreaks]
•{nbsp} *buffer*: buffer _(required)_

*Details:*



== InterpretedExternalBuffer

**

[%hardbreaks]
•{nbsp} *pointer*: int in [0, ∞) _(required)_
•{nbsp} *numbytes*: int in [0, ∞) _(required)_
•{nbsp} *external_source*: one of {`+ExternalBuffer.memory+`, `+ExternalBuffer.samefile+`, `+ExternalBuffer.file+`, `+ExternalBuffer.url+`} +
_(default: `+ExternalBuffer.memory+`)_
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
_(default: null/empty)_
•{nbsp} *postfilter_slice*: slice (start:stop:step) _(default: null)_
•{nbsp} *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`} +
_(default: `+Interpretation.none+`)_
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
_(default: `+Interpretation.little_endian+`)_
•{nbsp} *dimension_order*: one of {`+InterpretedBuffer.c_order+`, `+InterpretedBuffer.fortran+`} +
_(default: `+InterpretedBuffer.c_order+`)_
•{nbsp} *location*: str _(default: null)_

*Details:*



== Profile

**

[%hardbreaks]
•{nbsp} *expression*: str _(required)_
•{nbsp} *statistics*: <<Statistics>> _(required)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_

*Details:*



== Statistics

**

[%hardbreaks]
•{nbsp} *moments*: list of <<Moments>> _(default: null/empty)_
•{nbsp} *quantiles*: list of <<Quantiles>> _(default: null/empty)_
•{nbsp} *mode*: <<Modes>> _(default: null)_
•{nbsp} *min*: <<Extremes>> _(default: null)_
•{nbsp} *max*: <<Extremes>> _(default: null)_

*Details:*



== Moments

**

[%hardbreaks]
•{nbsp} *sumwxn*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *n*: int in [‒128, 127] _(required)_
•{nbsp} *weightpower*: int in [‒128, 127] _(default: 0)_
•{nbsp} *filter*: <<StatisticFilter>> _(default: null)_

*Details:*



== Quantiles

**

[%hardbreaks]
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *p*: float in [0.0, 1.0] _(required)_
•{nbsp} *weightpower*: int in [‒128, 127] _(default: 0)_
•{nbsp} *filter*: <<StatisticFilter>> _(default: null)_

*Details:*



== Modes

**

[%hardbreaks]
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *filter*: <<StatisticFilter>> _(default: null)_

*Details:*



== Extremes

**

[%hardbreaks]
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *filter*: <<StatisticFilter>> _(default: null)_

*Details:*



== StatisticFilter

**

[%hardbreaks]
•{nbsp} *min*: float in [‒∞, ∞] _(default: ‒∞)_
•{nbsp} *max*: float in [‒∞, ∞] _(default: ∞)_
•{nbsp} *excludes_minf*: bool _(default: false)_
•{nbsp} *excludes_pinf*: bool _(default: false)_
•{nbsp} *excludes_nan*: bool _(default: false)_

*Details:*



== Covariance

**

[%hardbreaks]
•{nbsp} *xindex*: int in [0, ∞) _(required)_
•{nbsp} *yindex*: int in [0, ∞) _(required)_
•{nbsp} *sumwxy*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *weightpower*: int in [‒128, 127] _(default: 0)_
•{nbsp} *filter*: <<StatisticFilter>> _(default: null)_

*Details:*



== ParameterizedFunction

**

[%hardbreaks]
•{nbsp} *expression*: str _(required)_
•{nbsp} *parameters*: list of <<Parameter>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_

*Details:*



== Parameter

**

[%hardbreaks]
•{nbsp} *identifier*: unique str _(required)_
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_

*Details:*



== EvaluatedFunction

**

[%hardbreaks]
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *derivatives*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(default: null)_
•{nbsp} *errors*: list of <<Quantiles>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_

*Details:*



== BinnedEvaluatedFunction

**

[%hardbreaks]
•{nbsp} *axis*: list of <<Axis>> with length in [1, ∞) _(required)_
•{nbsp} *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(required)_
•{nbsp} *derivatives*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
_(default: null)_
•{nbsp} *errors*: list of <<Quantiles>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_

*Details:*



== Ntuple

**

[%hardbreaks]
•{nbsp} *columns*: list of <<Column>> with length in [1, ∞) _(required)_
•{nbsp} *instances*: list of <<NtupleInstance>> with length in [1, ∞) _(required)_
•{nbsp} *column_statistics*: list of <<Statistics>> _(default: null/empty)_
•{nbsp} *column_covariances*: list of <<Covariance>> _(default: null/empty)_
•{nbsp} *functions*: str → <<ParameterizedFunction>> or <<BinnedEvaluatedFunction>> _(default: null/empty)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_
•{nbsp} *script*: str _(default: null)_

*Details:*



== Column

**

[%hardbreaks]
•{nbsp} *identifier*: unique str _(required)_
•{nbsp} *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`} +
_(required)_
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
_(default: `+Interpretation.little_endian+`)_
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
_(default: null/empty)_
•{nbsp} *postfilter_slice*: slice (start:stop:step) _(default: null)_
•{nbsp} *title*: str _(default: null)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_
•{nbsp} *decoration*: <<Decoration>> _(default: null)_

*Details:*



== NtupleInstance

**

[%hardbreaks]
•{nbsp} *chunks*: list of <<Chunk>> _(required)_
•{nbsp} *chunk_offsets*: list of int _(default: null/empty)_

*Details:*



== Chunk

**

[%hardbreaks]
•{nbsp} *column_chunks*: list of <<ColumnChunk>> _(required)_
•{nbsp} *metadata*: <<Metadata>> _(default: null)_

*Details:*



== ColumnChunk

**

[%hardbreaks]
•{nbsp} *pages*: list of <<Page>> _(required)_
•{nbsp} *page_offsets*: list of int with length in [1, ∞) _(required)_
•{nbsp} *page_min*: list of <<Extremes>> _(default: null/empty)_
•{nbsp} *page_max*: list of <<Extremes>> _(default: null/empty)_

*Details:*



== Page

**

[%hardbreaks]
•{nbsp} *buffer*: <<RawInlineBuffer>> or <<RawExternalBuffer>> _(required)_

*Details:*



== RawInlineBuffer

**

[%hardbreaks]
•{nbsp} *buffer*: buffer _(required)_

*Details:*



== RawExternalBuffer

**

[%hardbreaks]
•{nbsp} *pointer*: int in [0, ∞) _(required)_
•{nbsp} *numbytes*: int in [0, ∞) _(required)_
•{nbsp} *external_source*: one of {`+ExternalBuffer.memory+`, `+ExternalBuffer.samefile+`, `+ExternalBuffer.file+`, `+ExternalBuffer.url+`} +
_(default: `+ExternalBuffer.memory+`)_

*Details:*



== Metadata

**

[%hardbreaks]
•{nbsp} *data*: str _(required)_
•{nbsp} *language*: one of {`+Metadata.unspecified+`, `+Metadata.json+`} _(required)_

*Details:*



== Decoration

**

[%hardbreaks]
•{nbsp} *data*: str _(required)_
•{nbsp} *language*: one of {`+Decoration.unspecified+`, `+Decoration.css+`, `+Decoration.vega+`, `+Decoration.root_json+`} +
_(required)_

*Details:*


