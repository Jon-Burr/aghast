= Stagg Specification

== Introduction

== Basic Types



== Collection

*Collection of named objects, possibly with one or more common axis.*

[%hardbreaks]
•{nbsp} *objects*: str → <<Histogram>> or <<Ntuple>> or <<ParameterizedFunction>> or <<BinnedEvaluatedFunction>> or <<Collection>> +
(default: null/empty)
•{nbsp} *axis*: list of <<Axis>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)

*Details:*

A simple reason for using a collection would be to gather many objects into a convenient package that can be transmitted as a group. For this purpose, *axis* should be empty. Note that objects (such as histograms, functions, and ntuples) do not have names on their own; names are just keys in the *objects* property, used solely for lookup.

Assigning an *axis* to a collection, rather than individually to all objects it contains, is to avoid duplication when defining similarly binned data. As an example of the latter, consider histograms three `h1`, `h2`, `h3` with two sets of cuts applied, `"signal"` and `"control"` (six histograms total).

    Collection({"h1": h1, "h2": h2, "h3": h3},
               axis=[Axis(PredicateBinning("signal"), PredicateBinning("control"))])

This predicate axis (defined by if-then rules when the histograms were filled) is prepended onto the axes defined in each histogram separately. For instance, if `h1` had one regular axis and `h2` had two irregular axes, the `"h1"` in this collection has two axes: predicate, then regular, and the `"h2"` in this collection has three axes: predicate, then irregular, then irregular. This way, hundreds or thousands of histograms with similar binning can be defined in a contiguous block without repetition of axis definition (good for efficiency and avoiding copy-paste errors).

To subdivide one set of objects and not another, or to subdivide two sets of objects differently, put collections inside of collections. In the following example, `h1` and `h2` are subdivided but `h3` is not.

    Collection({"by region":
                    Collection({"h1": h1, "h2": h2},
                    axis=[Axis(PredicateBinning("signal"), PredicateBinning("control"))]),
                "h3": h3})

Similarly, regions can be subdivided into subregions, and other binning types may be used.

The buffers for each object must be the appropriate size to represent all of its axes, including any inherited from collections. (For example, a counts buffer appropriate for a standalone `h1` would not fit an `"h1"` with prepended axes due to being in a collection.)

The *title*, *metadata*, *decoration*, and *script* properties have no semantic constraints.

== Histogram

*Histogram of a distribution, defined by a (possibly weighted) count of observations in each bin of an n-dimensional space.*

[%hardbreaks]
•{nbsp}required  *axis*: list of <<Axis>> with length in [1, ∞)
•{nbsp}required  *counts*: <<UnweightedCounts>> or <<WeightedCounts>>
•{nbsp} *profile*: list of <<Profile>> (default: null/empty)
•{nbsp} *axis_covariances*: list of <<Covariance>> (default: null/empty)
•{nbsp} *profile_covariances*: list of <<Covariance>> (default: null/empty)
•{nbsp} *functions*: str → <<ParameterizedFunction>> or <<EvaluatedFunction>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)
The *xindex* and *yindex* of each Covariance in *axis_covariances* must be in [0, number of *axis*) and be unique pairs. +
The *xindex* and *yindex* of each Covariance in *profile_covariances* must be in [0, number of *profile*) and be unique pairs.

*Details:*

The space is subdivided by an n-dimensional *axis*. As described in <<Collection>>, nesting a histogram within a collection prepends the collection's *axis*. The number of <<Axis>> objects is not necessarily the dimensionality of the space; some binnings, such as <<HexagonalBinning>>, define more than one dimension (though most do not).

The *counts* are separate from the *axis*, though the buffers providing counts must be exactly the right size to fit the n-dimensional binning (including axes inherited from a <<Collection>>).

Histograms with only *axis* and *counts* are pure distributions, histograms in the conventional sense. All other properties provide additional information about the dataset.

Any *profiles* summarize dependent variables (where the *axis* defines independent variables). For instance, a profile can represent mean and standard deviation `y` values for an axis binned in `x`.

The <<Axis>> and <<Profile>> classes internally define summary statistics, such as the mean or median of that axis. However, those <<Statistics>> objects cannot describe correlations among axes. If this information is available, it can be expressed in *axis_covariances* or *profile_covariances*.

Any *functions* associated with the histogram, such as fit results, may be attached directly to the histogram object with names.

The *title*, *metadata*, *decoration*, and *script* properties have no semantic constraints.

*See also:*

   * <<BinnedEvaluatedFunction>>: for lookup functions that aren't statistical distributions.

== Axis

*Axis of a histogram or binned function representing one or more binned dimensions.*

[%hardbreaks]
•{nbsp} *binning*: <<IntegerBinning>> or <<RegularBinning>> or <<HexagonalBinning>> or <<EdgesBinning>> or <<IrregularBinning>> or <<CategoryBinning>> or <<SparseRegularBinning>> or <<FractionBinning>> or <<PredicateBinning>> or <<VariationBinning>> +
(default: null)
•{nbsp} *expression*: str (default: null)
•{nbsp} *statistics*: list of <<Statistics>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
The *statistics* must be empty or have a length equal to the number of dimensions in the *binning* (no binning is one-dimensional).

*Details:*

The dimension or dimensions are subdivided by the *binning* property; all other properties provide additional information.

If the axis represents a computed *expression*, it may be encoded here as a string. The *title* is a human-readable description.

A <<Statistics>> object (one per dimension) summarizes the data separately from the histogram counts. For instance, it may contain the mean and standard deviation of all data along a dimension, which is more accurate than a mean and standard deviation derived from the counts.

The *expression*, *title*, *metadata*, and *decoration* properties have no semantic constraints.

== IntegerBinning

*Splits an axis into a dense set of integer-sized bins, aligned to integers.*

[%hardbreaks]
•{nbsp}required  *min*: int in (‒∞, ∞)
•{nbsp}required  *max*: int in (‒∞, ∞)
•{nbsp} *loc_underflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)
The *min* must be strictly less than the *max*. +
The *loc_underflow* and *loc_overflow* must not be equal unless they are `nonexistent`.

*Details:*

This binning is intended for one-dimensional, integer-valued data in a compact range. The *min* and *max* values are both inclusive, so the number of bins is `+1 + max - min+`.

If *loc_underflow* and *loc_overflow* are `nonexistent`, then there are no slots in the <<Histogram>> counts or <<BinnedEvaluatedFunction>> values for underflow or overflow. If they are `below`, then their slots precede the normal bins, if `above`, then their slots follow the normal bins, and their order is in sequence: `below3`, `below2`, `below1`, (normal bins), `above1`, `above2`, `above3`.

== RegularBinning

**

[%hardbreaks]
•{nbsp}required  *num*: int in [1, ∞)
•{nbsp}required  *interval*: <<RealInterval>>
•{nbsp} *overflow*: <<RealOverflow>> (default: null)
•{nbsp} *circular*: bool (default: false)

*Details:*



== RealInterval

**

[%hardbreaks]
•{nbsp}required  *low*: float in [‒∞, ∞]
•{nbsp}required  *high*: float in [‒∞, ∞]
•{nbsp} *low_inclusive*: bool (default: true)
•{nbsp} *high_inclusive*: bool (default: false)

*Details:*



== RealOverflow

*Underflow, overflow, and nanflow configuration for one-dimensional, real-valued data.*

[%hardbreaks]
•{nbsp} *loc_underflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)
•{nbsp} *loc_nanflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)
•{nbsp} *minf_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
(default: `+RealOverflow.in_underflow+`)
•{nbsp} *pinf_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
(default: `+RealOverflow.in_overflow+`)
•{nbsp} *nan_mapping*: one of {`+RealOverflow.missing+`, `+RealOverflow.in_underflow+`, `+RealOverflow.in_overflow+`, `+RealOverflow.in_nanflow+`} +
(default: `+RealOverflow.in_nanflow+`)
The *loc_underflow*, *loc_overflow*, and *loc_nanflow* must not be equal unless they are `nonexistent`. +
The *minf_mapping* (‒∞ mapping) can only be `missing`, `in_underflow`, or `in_nanflow`, not `in_overflow`. +
The *pinf_mapping* (+∞ mapping) can only be `missing`, `in_overflow`, or `in_nanflow`, not `in_underflow`.

*Details:*

If *loc_underflow*, *loc_overflow*, and *loc_nanflow* are `nonexistent`, then there are no slots in the <<Histogram>> counts or <<BinnedEvaluatedFunction>> values for underflow, overflow, or nanflow. Underflow represents values less than the lower limit of the binning, overflow represents values greater than the upper limit of the binning, and nanflow represents floating-point values that are `nan` (not a number). With the normal bins, underflow, overflow, and nanflow, every possible input value corresponds to some bin.

If any of the *loc_underflow*, *loc_overflow*, and *loc_nanflow* are `below`, then their slots precede the normal bins, if `above`, then their slots follow the normal bins, and their order is in sequence: `below3`, `below2`, `below1`, (normal bins), `above1`, `above2`, `above3`.

The *minf_mapping* specifies whether ‒∞ values were ignored when the histogram was filled (`missing`), are in the underflow bin (`in_underflow`) or are in the nanflow bin (`in_nanflow`). The *pinf_mapping* specifies whether +∞ values were ignored when the histogram was filled (`missing`), are in the overflow bin (`in_overflow`) or are in the nanflow bin (`in_nanflow`). Thus, it would be possible to represent a histogram that was filled with finite underflow/overflow bins and a generic bin for all three non-finite floating point states.

== HexagonalBinning

**

[%hardbreaks]
•{nbsp}required  *qmin*: int in (‒∞, ∞)
•{nbsp}required  *qmax*: int in (‒∞, ∞)
•{nbsp}required  *rmin*: int in (‒∞, ∞)
•{nbsp}required  *rmax*: int in (‒∞, ∞)
•{nbsp} *coordinates*: one of {`+HexagonalBinning.offset+`, `+HexagonalBinning.doubled_offset+`, `+HexagonalBinning.cube_xy+`, `+HexagonalBinning.cube_yz+`, `+HexagonalBinning.cube_xz+`} +
(default: `+HexagonalBinning.offset+`)
•{nbsp} *xorigin*: float in (‒∞, ∞) (default: 0.0)
•{nbsp} *yorigin*: float in (‒∞, ∞) (default: 0.0)
•{nbsp} *qangle*: float in [‒π/2, π/2] (default: 0.0)
•{nbsp} *qoverflow*: <<RealOverflow>> (default: null)
•{nbsp} *roverflow*: <<RealOverflow>> (default: null)

*Details:*



== EdgesBinning

**

[%hardbreaks]
•{nbsp}required  *edges*: list of float with length in [1, ∞)
•{nbsp} *overflow*: <<RealOverflow>> (default: null)
•{nbsp} *low_inclusive*: bool (default: true)
•{nbsp} *high_inclusive*: bool (default: false)
•{nbsp} *circular*: bool (default: false)

*Details:*



== IrregularBinning

**

[%hardbreaks]
•{nbsp}required  *intervals*: list of <<RealInterval>> with length in [1, ∞)
•{nbsp} *overflow*: <<RealOverflow>> (default: null)
•{nbsp} *overlapping_fill*: one of {`+IrregularBinning.undefined+`, `+IrregularBinning.all+`, `+IrregularBinning.first+`, `+IrregularBinning.last+`} +
(default: `+IrregularBinning.undefined+`)

*Details:*



== CategoryBinning

**

[%hardbreaks]
•{nbsp}required  *categories*: list of str
•{nbsp} *loc_overflow*: one of {`+BinLocation.below3+`, `+BinLocation.below2+`, `+BinLocation.below1+`, `+BinLocation.nonexistent+`, `+BinLocation.above1+`, `+BinLocation.above2+`, `+BinLocation.above3+`} +
(default: `+BinLocation.nonexistent+`)

*Details:*



== SparseRegularBinning

**

[%hardbreaks]
•{nbsp}required  *bins*: list of int
•{nbsp}required  *bin_width*: float in (0, ∞]
•{nbsp} *origin*: float in [‒∞, ∞] (default: 0.0)
•{nbsp} *overflow*: <<RealOverflow>> (default: null)
•{nbsp} *low_inclusive*: bool (default: true)
•{nbsp} *high_inclusive*: bool (default: false)
•{nbsp} *minbin*: int in [‒2⁶³, 2⁶³ ‒ 1] (default: ‒2⁶³)
•{nbsp} *maxbin*: int in [‒2⁶³, 2⁶³ ‒ 1] (default: 2⁶³ ‒ 1)

*Details:*



== FractionBinning

**

[%hardbreaks]
•{nbsp} *layout*: one of {`+FractionBinning.passall+`, `+FractionBinning.failall+`, `+FractionBinning.passfail+`} +
(default: `+FractionBinning.passall+`)
•{nbsp} *layout_reversed*: bool (default: false)
•{nbsp} *error_method*: one of {`+FractionBinning.undefined+`, `+FractionBinning.normal+`, `+FractionBinning.clopper_pearson+`, `+FractionBinning.wilson+`, `+FractionBinning.agresti_coull+`, `+FractionBinning.feldman_cousins+`, `+FractionBinning.jeffrey+`, `+FractionBinning.bayesian_uniform+`} +
(default: `+FractionBinning.undefined+`)

*Details:*



== PredicateBinning

**

[%hardbreaks]
•{nbsp}required  *predicates*: list of str with length in [1, ∞)
•{nbsp} *overlapping_fill*: one of {`+IrregularBinning.undefined+`, `+IrregularBinning.all+`, `+IrregularBinning.first+`, `+IrregularBinning.last+`} +
(default: `+IrregularBinning.undefined+`)

*Details:*



== VariationBinning

**

[%hardbreaks]
•{nbsp}required  *variations*: list of <<Variation>> with length in [1, ∞)

*Details:*



== Variation

**

[%hardbreaks]
•{nbsp}required  *assignments*: list of <<Assignment>>
•{nbsp} *systematic*: list of float (default: null/empty)
•{nbsp} *category_systematic*: list of str (default: null/empty)

*Details:*



== Assignment

**

[%hardbreaks]
•{nbsp}required  *identifier*: unique str
•{nbsp}required  *expression*: str

*Details:*



== UnweightedCounts

**

[%hardbreaks]
•{nbsp}required  *counts*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>

*Details:*



== WeightedCounts

**

[%hardbreaks]
•{nbsp}required  *sumw*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *sumw2*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
(default: null)
•{nbsp} *unweighted*: <<UnweightedCounts>> (default: null)

*Details:*



== InterpretedInlineBuffer

**

[%hardbreaks]
•{nbsp}required  *buffer*: buffer
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
(default: null/empty)
•{nbsp} *postfilter_slice*: slice (start:stop:step) (default: null)
•{nbsp} *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`} +
(default: `+Interpretation.none+`)
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
(default: `+Interpretation.little_endian+`)
•{nbsp} *dimension_order*: one of {`+InterpretedBuffer.c_order+`, `+InterpretedBuffer.fortran+`} +
(default: `+InterpretedBuffer.c_order+`)

*Details:*



== InterpretedInlineInt64Buffer

**

[%hardbreaks]
•{nbsp}required  *buffer*: buffer

*Details:*



== InterpretedInlineFloat64Buffer

**

[%hardbreaks]
•{nbsp}required  *buffer*: buffer

*Details:*



== InterpretedExternalBuffer

**

[%hardbreaks]
•{nbsp}required  *pointer*: int in [0, ∞)
•{nbsp}required  *numbytes*: int in [0, ∞)
•{nbsp} *external_source*: one of {`+ExternalBuffer.memory+`, `+ExternalBuffer.samefile+`, `+ExternalBuffer.file+`, `+ExternalBuffer.url+`} +
(default: `+ExternalBuffer.memory+`)
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
(default: null/empty)
•{nbsp} *postfilter_slice*: slice (start:stop:step) (default: null)
•{nbsp} *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`} +
(default: `+Interpretation.none+`)
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
(default: `+Interpretation.little_endian+`)
•{nbsp} *dimension_order*: one of {`+InterpretedBuffer.c_order+`, `+InterpretedBuffer.fortran+`} +
(default: `+InterpretedBuffer.c_order+`)
•{nbsp} *location*: str (default: null)

*Details:*



== Profile

**

[%hardbreaks]
•{nbsp}required  *expression*: str
•{nbsp}required  *statistics*: <<Statistics>>
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)

*Details:*



== Statistics

**

[%hardbreaks]
•{nbsp} *moments*: list of <<Moments>> (default: null/empty)
•{nbsp} *quantiles*: list of <<Quantiles>> (default: null/empty)
•{nbsp} *mode*: <<Modes>> (default: null)
•{nbsp} *min*: <<Extremes>> (default: null)
•{nbsp} *max*: <<Extremes>> (default: null)

*Details:*



== Moments

**

[%hardbreaks]
•{nbsp}required  *sumwxn*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp}required  *n*: int in [‒128, 127]
•{nbsp} *weightpower*: int in [‒128, 127] (default: 0)
•{nbsp} *filter*: <<StatisticFilter>> (default: null)

*Details:*



== Quantiles

**

[%hardbreaks]
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp}required  *p*: float in [0.0, 1.0] (default: 1/2)
•{nbsp} *weightpower*: int in [‒128, 127] (default: 0)
•{nbsp} *filter*: <<StatisticFilter>> (default: null)

*Details:*



== Modes

**

[%hardbreaks]
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *filter*: <<StatisticFilter>> (default: null)

*Details:*



== Extremes

**

[%hardbreaks]
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *filter*: <<StatisticFilter>> (default: null)

*Details:*



== StatisticFilter

**

[%hardbreaks]
•{nbsp} *min*: float in [‒∞, ∞] (default: ‒∞)
•{nbsp} *max*: float in [‒∞, ∞] (default: ∞)
•{nbsp} *excludes_minf*: bool (default: false)
•{nbsp} *excludes_pinf*: bool (default: false)
•{nbsp} *excludes_nan*: bool (default: false)

*Details:*



== Covariance

**

[%hardbreaks]
•{nbsp}required  *xindex*: int in [0, ∞)
•{nbsp}required  *yindex*: int in [0, ∞)
•{nbsp}required  *sumwxy*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *weightpower*: int in [‒128, 127] (default: 0)
•{nbsp} *filter*: <<StatisticFilter>> (default: null)

*Details:*



== ParameterizedFunction

**

[%hardbreaks]
•{nbsp}required  *expression*: str
•{nbsp} *parameters*: list of <<Parameter>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)

*Details:*



== Parameter

**

[%hardbreaks]
•{nbsp}required  *identifier*: unique str
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>

*Details:*



== EvaluatedFunction

**

[%hardbreaks]
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *derivatives*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
(default: null)
•{nbsp} *errors*: list of <<Quantiles>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)

*Details:*



== BinnedEvaluatedFunction

**

[%hardbreaks]
•{nbsp}required  *axis*: list of <<Axis>> with length in [1, ∞)
•{nbsp}required  *values*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>>
•{nbsp} *derivatives*: <<InterpretedInlineBuffer>> or <<InterpretedInlineInt64Buffer>> or <<InterpretedInlineFloat64Buffer>> or <<InterpretedExternalBuffer>> +
(default: null)
•{nbsp} *errors*: list of <<Quantiles>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)

*Details:*



== Ntuple

**

[%hardbreaks]
•{nbsp}required  *columns*: list of <<Column>> with length in [1, ∞)
•{nbsp}required  *instances*: list of <<NtupleInstance>> with length in [1, ∞)
•{nbsp} *column_statistics*: list of <<Statistics>> (default: null/empty)
•{nbsp} *column_covariances*: list of <<Covariance>> (default: null/empty)
•{nbsp} *functions*: str → <<ParameterizedFunction>> or <<BinnedEvaluatedFunction>> (default: null/empty)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)
•{nbsp} *script*: str (default: null)

*Details:*



== Column

**

[%hardbreaks]
•{nbsp}required  *identifier*: unique str
•{nbsp}required  *dtype*: one of {`+Interpretation.none+`, `+Interpretation.bool+`, `+Interpretation.int8+`, `+Interpretation.uint8+`, `+Interpretation.int16+`, `+Interpretation.uint16+`, `+Interpretation.int32+`, `+Interpretation.uint32+`, `+Interpretation.int64+`, `+Interpretation.uint64+`, `+Interpretation.float32+`, `+Interpretation.float64+`}
•{nbsp} *endianness*: one of {`+Interpretation.little_endian+`, `+Interpretation.big_endian+`} +
(default: `+Interpretation.little_endian+`)
•{nbsp} *filters*: list of {`+Buffer.none+`, `+Buffer.gzip+`, `+Buffer.lzma+`, `+Buffer.lz4+`} +
(default: null/empty)
•{nbsp} *postfilter_slice*: slice (start:stop:step) (default: null)
•{nbsp} *title*: str (default: null)
•{nbsp} *metadata*: <<Metadata>> (default: null)
•{nbsp} *decoration*: <<Decoration>> (default: null)

*Details:*



== NtupleInstance

**

[%hardbreaks]
•{nbsp}required  *chunks*: list of <<Chunk>>
•{nbsp} *chunk_offsets*: list of int (default: null/empty)

*Details:*



== Chunk

**

[%hardbreaks]
•{nbsp}required  *column_chunks*: list of <<ColumnChunk>>
•{nbsp} *metadata*: <<Metadata>> (default: null)

*Details:*



== ColumnChunk

**

[%hardbreaks]
•{nbsp}required  *pages*: list of <<Page>>
•{nbsp}required  *page_offsets*: list of int with length in [1, ∞)
•{nbsp} *page_min*: list of <<Extremes>> (default: null/empty)
•{nbsp} *page_max*: list of <<Extremes>> (default: null/empty)

*Details:*



== Page

**

[%hardbreaks]
•{nbsp}required  *buffer*: <<RawInlineBuffer>> or <<RawExternalBuffer>>

*Details:*



== RawInlineBuffer

**

[%hardbreaks]
•{nbsp}required  *buffer*: buffer

*Details:*



== RawExternalBuffer

**

[%hardbreaks]
•{nbsp}required  *pointer*: int in [0, ∞)
•{nbsp}required  *numbytes*: int in [0, ∞)
•{nbsp} *external_source*: one of {`+ExternalBuffer.memory+`, `+ExternalBuffer.samefile+`, `+ExternalBuffer.file+`, `+ExternalBuffer.url+`} +
(default: `+ExternalBuffer.memory+`)

*Details:*



== Metadata

**

[%hardbreaks]
•{nbsp}required  *data*: str
•{nbsp}required  *language*: one of {`+Metadata.unspecified+`, `+Metadata.json+`} (default: `+Metadata.unspecified+`)

*Details:*



== Decoration

**

[%hardbreaks]
•{nbsp}required  *data*: str
•{nbsp}required  *language*: one of {`+Decoration.unspecified+`, `+Decoration.css+`, `+Decoration.vega+`, `+Decoration.root_json+`} +
(default: `+Decoration.unspecified+`)

*Details:*


