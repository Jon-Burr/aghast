namespace portally_generated;

///////////////////////////////////////////////// metadata

enum MetadataLanguage: uint {
  meta_unspecified = 0,
  meta_json = 1,
}

table Metadata {
  data: string (required);
  language: MetadataLanguage = meta_unspecified;
}

///////////////////////////////////////////////// decoration

enum DecorationLanguage: uint {
  deco_unspecified = 0,
  deco_css = 1,
  deco_vega = 2,
  deco_root_json = 3
}

table Decoration {
  data: string (required);
  language: DecorationLanguage = deco_unspecified;
}

///////////////////////////////////////////////// buffers

enum DType: byte {
  dtype_none = 0,
  dtype_int8 = 1,
  dtype_uint8 = 2,
  dtype_int16 = 3,
  dtype_uint16 = 4,
  dtype_int32 = 5,
  dtype_uint32 = 6,
  dtype_int64 = 7,
  dtype_uint64 = 8,
  dtype_float32 = 9,
  dtype_float64 = 10
}

enum Endianness: byte {
  little_endian = 0,
  big_endian = 1,
}

enum DimensionOrder: byte {
  c_order = 0,
  fortran_order = 1
}

enum Filter: int {
  filter_none = 0,
  filter_gzip = 1,
  filter_lzma = 2,
  filter_lz4 = 3
  // not just compression; any 1-to-1 buffer transformation
}

struct Slice {
  start: long;
  stop: long;
  step: int;
  has_start: bool;
  has_stop: bool;
  has_step: bool;
}

enum ExternalType: int {
  external_memory = 0,
  external_samefile = 1,
  external_file = 2,
  external_url = 3
}

table RawInlineBuffer {
  buffer: [ubyte] (required);
}

table RawExternalBuffer {
  pointer: ulong;
  numbytes: ulong;
  external_type: ExternalType = external_memory;
  location: string;
}

table InterpretedInlineBuffer {
  buffer: [ubyte] (required);
  filters: [Filter];
  postfilter_slice: Slice;
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  dimension_order: DimensionOrder = c_order;
}

table InterpretedExternalBuffer {
  pointer: ulong;
  numbytes: ulong;
  external_type: ExternalType = external_memory;
  filters: [Filter];
  postfilter_slice: Slice;
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  dimension_order: DimensionOrder = c_order;
  location: string;
}

union RawBuffer {
  RawInlineBuffer,
  RawExternalBuffer
}

union InterpretedBuffer {
  InterpretedInlineBuffer,
  InterpretedExternalBuffer
}

///////////////////////////////////////////////// descriptive statistics

table StatisticFilter {
  minimum: double;
  maximum: double;
  excludes_minf: bool;
  excludes_pinf: bool;
  excludes_nan: bool;
}

table Moments {
  sumwxn: InterpretedBuffer (required);
  n: int;
  weighted: bool = true;
  filter: StatisticFilter;
}

table Extremes {
  values: InterpretedBuffer (required);
  filter: StatisticFilter;
}

table Quantiles {
  values: InterpretedBuffer (required);
  p: double = 0.5;    // 0.0 <= p <= 1.0
  weighted: bool = true;
  filter: StatisticFilter;
}

table Modes {
  values: InterpretedBuffer (required);
  filter: StatisticFilter;
}

table Statistics {
  moments: [Moments];
  quantiles: [Quantiles];
  modes: Modes;
  minima: Extremes;
  maxima: Extremes;
}

table Correlations {
  xindex: int;
  yindex: int;
  sumwxy: InterpretedBuffer (required);   // one of the N*(N-1) elements
  weighted: bool = true;
  filter: StatisticFilter;
}

///////////////////////////////////////////////// binning

enum BinPosition: int8 {
  pos_below3 = -3,
  pos_below2 = -2,
  pos_below1 = -1,
  pos_nonexistent = 0,
  pos_above1 = 1,
  pos_above2 = 2,
  pos_above3 = 3
}

table IntegerBinning {
  minimum: long;   // assumed to be inclusive (if not, change its value!)
  maximum: long;
  pos_underflow: BinPosition = pos_nonexistent;
  pos_overflow: BinPosition = pos_nonexistent;
}

table RealInterval {
  low: double;
  high: double;
  low_inclusive: bool = true;
  high_inclusive: bool = false;
}

enum NonRealMapping: byte {
  missing = 0,
  in_underflow = 1,
  in_overflow = 2,
  in_nanflow = 3
}

table RealOverflow {
  pos_underflow: BinPosition = pos_nonexistent;
  pos_overflow: BinPosition = pos_nonexistent;
  pos_nanflow: BinPosition = pos_nonexistent;
  minf_mapping: NonRealMapping = in_underflow;
  pinf_mapping: NonRealMapping = in_overflow;
  nan_mapping: NonRealMapping = in_nanflow;
}

table RegularBinning {
  num: ulong;
  interval: RealInterval (required);
  overflow: RealOverflow;
  circular: bool = false;
}

table TicTacToeOverflowBinning {
  xnum: ulong;
  ynum: ulong;
  xinterval: RealInterval (required);
  yinterval: RealInterval (required);
  xoverflow: RealOverflow;
  yoverflow: RealOverflow;
}

// https://www.redblobgames.com/grids/hexagons
enum HexagonalCoordinates: byte {
  hex_offset = 0,
  hex_doubled_offset = 1,
  hex_cube_xy = 2,
  hex_cube_yz = 3,
  hex_cube_xz = 4
}

table HexagonalBinning {
  qmin: long;   // assumed to be inclusive (if not, change its value!)
  qmax: long;
  rmin: long;
  rmax: long;
  coordinates: HexagonalCoordinates = hex_offset;
  xorigin: double = 0.0;    // x coordinate of (q, r) == (0, 0)
  yorigin: double = 0.0;    // y coordinate of (q, r) == (0, 0)
  qangle: double = 0.0;     // angle of (q, r) == (1, 0) relative to (x, y) == (1, 0) in -pi/2 <= x <= pi/2
  qoverflow: RealOverflow;
  roverflow: RealOverflow;
}

table EdgesBinning {
  edges: [double] (required);
  overflow: RealOverflow;
}

enum OverlappingFillStrategy: byte {
  overfill_all = 0,
  overfill_first = 1,
  overfill_last = 2
}

table IrregularBinning {
  intervals: [RealInterval] (required);
  overflow: RealOverflow;
  overlapping_fill: OverlappingFillStrategy = overfill_all;
}

table CategoryBinning {
  categories: [string] (required);
  pos_overflow: BinPosition = pos_nonexistent;
}

table SparseRegularBinning {
  bins: [long] (required);
  bin_width: double;
  origin: double = 0.0;
  pos_nanflow: BinPosition = pos_nonexistent;
}

enum FractionLayout: byte {
  frac_passall = 0,
  frac_failall = 1,
  frac_passfail = 2
}

enum FractionErrorMethod: byte {
  frac_normal = 0,
  frac_clopper_pearson = 1,
  frac_wilson = 2,
  frac_agresti_coull = 3,
  frac_feldman_cousins = 4,
  frac_jeffrey = 5,
  frac_bayesian_uniform = 6
}

table FractionBinning {
  layout: FractionLayout = frac_passall;
  layout_reversed: bool = false;
  error_method: FractionErrorMethod = frac_normal;
}

table PredicateBinning {
  predicates: [string] (required);
}

table Assignment {
  identifier: string (key);
  expression: string (required);
}

table Variation {
  assignments: [Assignment] (required);
  systematic: [double];
  category_systematic: [string];
}

table VariationBinning {
  variations: [Variation] (required);
}

union Binning {
  IntegerBinning,
  RegularBinning,
  TicTacToeOverflowBinning,
  HexagonalBinning,
  EdgesBinning,
  IrregularBinning,
  CategoryBinning,
  SparseRegularBinning,
  FractionBinning,
  PredicateBinning,
  VariationBinning
}

///////////////////////////////////////////////// axis

table Axis {
  binning: Binning;      // note: it's allowed to have no binning
  expression: string;
  statistics: Statistics;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table Profile {
  expression: string (required);
  statistics: Statistics (required);
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

///////////////////////////////////////////////// distributions

table UnweightedCounts {
  counts: InterpretedBuffer (required);
}

table WeightedCounts {
  sumw: InterpretedBuffer (required);
  sumw2: InterpretedBuffer;               // optional
  unweighted: UnweightedCounts;           // optional
}

union Counts {
  UnweightedCounts,
  WeightedCounts
}

///////////////////////////////////////////////// functions

table Parameter {
  identifier: string (key);
  values: InterpretedBuffer;
}

table ParameterizedFunction {
  expression: string (required);
  parameters: [Parameter];
}

table EvaluatedFunction {
  values: InterpretedBuffer (required);
  derivatives: InterpretedBuffer;
  errors: [Quantiles];
}

// FIXME: ContourFunction? Has to specify its own number of points because it can't be determined by position

union FunctionData {
  ParameterizedFunction,
  EvaluatedFunction
  // ContourFunction
}

table Function {
  data: FunctionData (required);
  title: string;
  metadata: Metadata;
  decoration: Decoration;
  script: string;
}

table BinnedEvaluatedFunction {
  axis: [Axis] (required);
  data: EvaluatedFunction (required);
}

union FunctionObjectData {
  ParameterizedFunction,
  BinnedEvaluatedFunction
  // ContourFunction
}

table FunctionObject {
  data: FunctionObjectData (required);
}

///////////////////////////////////////////////// histogram

table Histogram {
  axis: [Axis] (required);
  counts: Counts (required);
  profile: [Profile];
  axis_correlations: [Correlations];
  profile_correlations: [Correlations];
  lookup_functions: [string];
  functions: [Function];
}

///////////////////////////////////////////////// ntuple

table Page {
  buffer: RawBuffer (required);
}

table ColumnChunk {
  pages: [Page] (required);
  page_offsets: [ulong] (required);
  page_minima: [Extremes];
  page_maxima: [Extremes];
}

table Chunk {
  column_chunks: [ColumnChunk] (required);
  metadata: Metadata;
}

table Column {
  identifier: string (key);
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  filters: [Filter];
  postfilter_slice: Slice;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table NtupleInstance {
  chunks: [Chunk] (required);
  chunk_offsets: [ulong];
}

table Ntuple {
  columns: [Column] (required);
  instances: [NtupleInstance] (required);
  column_statistics: [Statistics];
  column_correlations: [Correlations];
  lookup_functions: [string];
  functions: [FunctionObject];
}

///////////////////////////////////////////////// objects and collections

table Collection {
  lookup: [string];
  objects: [Object];
  axis: [Axis];
}

union ObjectData {
  Histogram,
  Ntuple,
  FunctionObject,
  Collection
}

table Object {
  data: ObjectData (required);
  title: string;
  metadata: Metadata;
  decoration: Decoration;
  script: string;
}

file_extension "port";
file_identifier "port";
root_type Object;
