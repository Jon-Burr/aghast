namespace histos_generated;

///////////////////////////////////////////////// Metadata

enum MetadataLanguage: uint {
  meta_unspecified = 0,
  meta_json = 1,
}

table Metadata {
  data: string (required);
  language: MetadataLanguage = meta_unspecified;
}

///////////////////////////////////////////////// Decoration

enum DecorationLanguage: uint {
  deco_unspecified = 0,
  deco_css = 1,
  deco_vega = 2,
  deco_root_json = 3
}

table Decoration {
  data: string (required);
  language: DecorationLanguage = deco_unspecified;
}

///////////////////////////////////////////////// Functions

table Parameter {
  identifier: string (key);
  value: double;
}

table ParameterizedFunction {
  expression: string (required);
  parameters: [Parameter] (required);
  contours: [double];
}

table EvaluatedFunction {
  values: [double] (required);
  derivatives: [double];
  generic_errors: [GenericErrors];
}

union FunctionData {
  ParameterizedFunction,
  EvaluatedFunction
}

table Function {
  identifier: string (key);
  data: FunctionData (required);
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

///////////////////////////////////////////////// Histogram

enum DType: byte {
  dtype_none = 0,
  dtype_int8 = 1,
  dtype_uint8 = 2,
  dtype_int16 = 3,
  dtype_uint16 = 4,
  dtype_int32 = 5,
  dtype_uint32 = 6,
  dtype_int64 = 7,
  dtype_uint64 = 8,
  dtype_float32 = 9,
  dtype_float64 = 10
}

enum Endianness: byte {
  little_endian = 0,
  big_endian = 1,
}

enum DimensionOrder: byte {
  c_order = 0,
  fortran_order = 1
}

enum Filter: int {
  filter_none = 0,
  filter_gzip = 1,
  filter_lzma = 2,
  filter_lz4 = 3
  // not just compression; any 1-to-1 buffer transformation
}

struct Slice {
  start: ulong;
  stop: ulong;
}

enum ExternalType: int {
  external_memory = 0,
  external_samefile = 1,
  external_file = 2,
  external_url = 3
}

table RawInlineBuffer {
  buffer: [ubyte] (required);
  filters: [Filter];
  postfilter_slice: Slice;
}

table RawExternalBuffer {
  pointer: ulong;
  numbytes: ulong;
  external_type: ExternalType = external_memory;
  filters: [Filter];
  postfilter_slice: Slice;
  location: string;
}

union RawBuffer {
  RawInlineBuffer,
  RawExternalBuffer
}

table InlineBuffer {
  buffer: [ubyte] (required);
  filters: [Filter];
  postfilter_slice: Slice;
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  dimension_order: DimensionOrder = c_order;
}

table ExternalBuffer {
  pointer: ulong;
  numbytes: ulong;
  external_type: ExternalType = external_memory;
  filters: [Filter];
  postfilter_slice: Slice;
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  dimension_order: DimensionOrder = c_order;
  location: string;
}

union Buffer {
  InlineBuffer,
  ExternalBuffer
}

enum FractionalErrorMethod: byte {
  frac_normal = 0,
  frac_clopper_pearson = 1,
  frac_wilson = 2,
  frac_agresti_coull = 3,
  frac_feldman_cousins = 4,
  frac_jeffrey = 5,
  frac_bayesian_uniform = 6
}

table FractionBinning {
  error_method: FractionalErrorMethod = frac_normal;
}

table IntegerBinning {
  min: long;   // assumed to be inclusive (if not, change its value!)
  max: long;
  has_underflow: bool = true;
  has_overflow: bool = true;
}

table RealInterval {
  low: double;
  high: double;
  low_inclusive: bool = true;
  high_inclusive: bool = false;
}

enum NonRealMapping: byte {
  missing = 0,
  in_underflow = 1,
  in_overflow = 2,
  in_nanflow = 3
}

table RealOverflow {
  has_underflow: bool = true;
  has_overflow: bool = true;
  has_nanflow: bool = true;
  minf_mapping: NonRealMapping = in_underflow;
  pinf_mapping: NonRealMapping = in_overflow;
  nan_mapping: NonRealMapping = in_nanflow;
}

table RegularBinning {
  num: ulong;
  interval: RealInterval (required);
  overflow: RealOverflow;
  circular: bool = false;
}

table TicTacToeOverflowBinning {
  numx: ulong;
  numy: ulong;
  x: RealInterval (required);
  y: RealInterval (required);
  overflow: RealOverflow (required);
}

// https://www.redblobgames.com/grids/hexagons
enum HexagonalCoordinates: byte {
  offset = 0,
  doubled_offset = 1,
  cube_xy = 2,
  cube_yz = 3,
  cube_xz = 4
}

table HexagonalBinning {
  q: IntegerBinning (required);
  r: IntegerBinning (required);
  coordinates: HexagonalCoordinates = offset;
  originx: double = 0.0;    // x coordinate of (q, r) == (0, 0)
  originy: double = 0.0;    // y coordinate of (q, r) == (0, 0)
}

table VariableBinning {
  intervals: [RealInterval] (required);
  overflow: RealOverflow;
}

table CategoryBinning {
  categories: [string] (required);
}

table SparseRegularBinning {
  bin_width: double;
  origin: double = 0.0;
  has_nanflow: bool = true;
}

union Binning {
  FractionBinning,
  IntegerBinning,
  RegularBinning,
  TicTacToeOverflowBinning,
  HexagonalBinning,
  VariableBinning,
  CategoryBinning,
  SparseRegularBinning
}

table Axis {
  binning: Binning;      // note: no binning is allowed
  expression: string;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table UnweightedCounts {
  counts: Buffer (required);
}

table WeightedCounts {
  sumw: Buffer (required);
  sumw2: Buffer (required);
  counts: Counts;
}

union Counts {
  UnweightedCounts,
  WeightedCounts
}

table Correlation {
  sumwx: Buffer (required);
  sumwxy: Buffer (required);   // symmetric matrix: N*(N+1) elements
}

table Extreme {
  min: double;
  max: double;
  excludes_minf: bool = false;
  excludes_pinf: bool = false;
  excludes_nan: bool = true;
}

table Moment {
  n: int;
  sumwn: Buffer (required);
}

table Quantile {
  p: double;    // 0.0 <= p <= 1.0
  value: Buffer (required);
}

table GenericErrors {
  error: Buffer (required);
  p: double = 0.6826894921370859;    // +1 sigma
}

table DistributionStats {
  correlation: Correlation;
  extremes: [Extreme];
  moments: [Moment];
  quantiles: [Quantile];
  generic_errors: [GenericErrors];
}

table Distribution {
  counts: Counts (required);
  stats: DistributionStats;
}

table Profile {
  expression: string;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table Histogram {
  axis: [Axis] (required);
  profiles: [Profile];
  distribution: Distribution (required);
  unbinned_stats: [DistributionStats];
  profile_stats: [DistributionStats];
  functions: [Function];
}

///////////////////////////////////////////////// Ntuple

table Page {
  buffer: RawBuffer (required);
}

table ColumnChunk {
  pages: [Page] (required);
  page_offsets: [ulong] (required);
  page_extremes: [Extreme];
}

table Chunk {
  columns: [ColumnChunk] (required);
  metadata: Metadata;
}

table Column {
  identifier: string (key);
  dtype: DType = dtype_none;
  endianness: Endianness = little_endian;
  dimension_order: DimensionOrder = c_order;
  filters: [Filter];
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table Ntuple {
  columns: [Column] (required);
  chunks: [Chunk] (required);
  chunk_offsets: [ulong] (required);
  unbinned_stats: [DistributionStats];
  functions: [Function];
}

///////////////////////////////////////////////// objects

union ObjectData {
  Histogram,
  Ntuple,
  ParameterizedFunction,
  EvaluatedFunction
}

table Object {
  identifier: string (key);
  data: ObjectData (required);
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

///////////////////////////////////////////////// collections

table Region {
  expressions: [string] (required);  // predicates to apply
}

table BinnedRegion {
  expression: string (required);     // expression to slice
  binning: Binning (required);
}

table Assignment {
  identifier: string (key);
  expression: string (required);
}

table Systematic {
  p: double = 0.6826894921370859;    // +1 sigma
  category: string;                  // optional
}

table Variation {
  assignments: [Assignment] (required);
  systematic: [Systematic];
}

table Collection {
  identifier: string (key);
  objects: [Object];
  collection: [Collection];          // nested ANDs
  regions: [Region];                 // list of ORs of (overlapping?) regions
  binned_regions: [BinnedRegion];    // list of ORs of exclusive, binned regions
  variations: [Variation];           // list of ORs with assignments
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

file_extension "hist";
file_identifier "hist";
root_type Collection;
