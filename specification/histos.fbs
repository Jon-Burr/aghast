namespace histos.generated;

///////////////////////////////////////////////// Decoration

enum DecorationLanguage: uint {
  deco_inline = 0,
  deco_css = 1,
  deco_vega = 2,
  deco_root_json = 3
}

table Decoration {
  language: DecorationLanguage;
  data: string;
}

///////////////////////////////////////////////// Metadata

enum MetadataLanguage: uint {
  meta_inline = 0,
  meta_json = 1,
}

table Metadata {
  language: MetadataLanguage;
  data: string;
}

///////////////////////////////////////////////// Functions




///////////////////////////////////////////////// Histogram

enum ErrorMethod: byte {
  frac_normal = 0,
  frac_clopper_pearson = 1,
  frac_wilson = 2,
  frac_agresti_coull = 3,
  frac_feldman_cousins = 4,
  frac_jeffrey = 5,
  frac_bayesian_uniform = 6
}

table FractionBinning {
  error_method: ErrorMethod;
}

table IntegerBinning {
  min: long;   // assumed to be inclusive (if not, change its value!)
  max: long;
  has_underflow: bool = true;
  has_overflow: bool = true;
}

table RealInterval {
  low: double;
  high: double;
  low_inclusive: bool = true;
  high_inclusive: bool = false;
}

enum NonRealMapping: byte {
  missing = 0,
  in_underflow = 1,
  in_overflow = 2,
  in_nanflow = 3
}

table RealOverflow {
  has_underflow: bool = true;
  has_overflow: bool = true;
  has_nanflow: bool = true;
  minf_mapping: NonRealMapping = in_underflow;
  pinf_mapping: NonRealMapping = in_underflow;
  nan_mapping: NonRealMapping = in_nanflow;
}

table RegularBinning {
  num: ulong;
  interval: RealInterval (required);
  overflow: RealOverflow;
  circular: bool = false;
}

table TicTacToeOverflowBinning {
  numx: ulong;
  numy: ulong;
  x: RealInterval (required);
  y: RealInterval (required);
  overflow: RealOverflow (required);
}

// https://www.redblobgames.com/grids/hexagons
enum HexagonalCoordinates: byte {
  offset = 0,
  doubled_offset = 1,
  cube_xy = 2,
  cube_yz = 3,
  cube_xz = 4
}

table HexagonalBinning {
  q: IntegerBinning (required);
  r: IntegerBinning (required);
  coordinates: HexagonalCoordinates = offset;
  originx: double = 0.0;    // x coordinate of (q, r) == (0, 0)
  originy: double = 0.0;    // y coordinate of (q, r) == (0, 0)
}

table VariableBinning {
  intervals: [RealInterval] (required);
  overflow: RealOverflow;
}

table CategoryBinning {
  categories: [string] (required);
}

table SparseRegularBinning {
  bin_width: double;
  origin: double = 0.0;
  nanflow: bool = true;
}

union Binning {
  FractionBinning,
  IntegerBinning,
  RegularBinning,
  TicTacToeOverflowBinning,
  HexagonalBinning,
  VariableBinning,
  CategoryBinning,
  SparseRegularBinning
}

table Region {
  expressions: [string];      // predicates to apply
}

table Slice {
  expression: string;         // expression to slice
  binning: Binning (required);
}

table Systematic {
  p: double = 0.6826894921370859;    // +1 sigma
  category: string;                  // optional
}

table Variation {
  expressions: [string];      // assignments in this block
  systematic: [Systematic];
}

table Multiplier {
  identifier: string (key);
  region: Region;
  slice: Slice;
  variations: [Variation];
  multiplier: [Multiplier];
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table Axis {
  binning: Binning;      // note: no binning is allowed
  expression: string;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table CountUInt8 {
  count: [ubyte] (required);
}

table CountUInt16 {
  count: [ushort] (required);
}

table CountUInt32 {
  count: [uint] (required);
}

table CountUInt64 {
  count: [ulong] (required);
}

table CountFloat32 {
  count: [float] (required);
}

table CountFloat64 {
  count: [double] (required);
}

union Count {
  CountUInt8,
  CountUInt16,
  CountUInt32,
  CountUInt64,
  CountFloat32,
  CountFloat64
}

table WeightedFloat32 {
  sumw: [float] (required);
  sumw2: [float] (required);
  count: Count;   // optional; can use if different from sumw
}

table WeightedFloat64 {
  sumw: [double] (required);
  sumw2: [double] (required);
  count: Count;   // optional; can use if different from sumw
}

union Content {
  CountUInt8,
  CountUInt16,
  CountUInt32,
  CountUInt64,
  CountFloat32,
  CountFloat64,
  WeightedFloat32,
  WeightedFloat64
}

table Correlation {
  sumwx: [double] (required);
  sumwxy: [double] (required);   // symmetric matrix: N*(N+1) elements
}

table Extreme {
  min: double;
  max: double;
}

table Moment {
  n: int;
  sumwn: [double] (required);
}

table Quantile {
  p: double;    // 0.0 <= p <= 1.0
  value: [double] (required);
}

table GenericError {
  error: double;
  p: double = 0.6826894921370859;    // +1 sigma
}

table DistributionStats {
  correlation: Correlation;
  extremes: [Extreme];
  moments: [Moment];
  quantiles: [Quantile];
  generic_errors: [GenericError];
}

table Distribution {
  content: Content (required);
  stats: DistributionStats;
}

table Profile {
  expression: string;
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

table Histogram {
  identifier: string (key);
  multipliers: [Multiplier];
  axis: [Axis] (required);
  profiles: [Profile];
  distribution: Distribution (required);
  unbinned_stats: [DistributionStats];
  profile_stats: [DistributionStats];
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

///////////////////////////////////////////////// Ntuple

table PageInt8 {
  data: [byte] (required);
}

table PagesInt8 {
  data: [PageInt8] (required);
}

table PageUInt8 {
  data: [ubyte] (required);
}

table PagesUInt8 {
  data: [PageUInt8] (required);
}

table PageInt16 {
  data: [short] (required);
}

table PagesInt16 {
  data: [PageInt16] (required);
}

table PageUInt16 {
  data: [ushort] (required);
}

table PagesUInt16 {
  data: [PageUInt16] (required);
}

table PageInt32 {
  data: [int] (required);
}

table PagesInt32 {
  data: [PageInt32] (required);
}

table PageUInt32 {
  data: [uint] (required);
}

table PagesUInt32 {
  data: [PageUInt32] (required);
}

table PageInt64 {
  data: [long] (required);
}

table PagesInt64 {
  data: [PageInt64] (required);
}

table PageUInt64 {
  data: [ulong] (required);
}

table PagesUInt64 {
  data: [PageUInt64] (required);
}

table PageFloat32 {
  data: [float] (required);
}

table PagesFloat32 {
  data: [PageFloat32] (required);
}

table PageFloat64 {
  data: [double] (required);
}

table PagesFloat64 {
  data: [PageFloat64] (required);
}

union Pages {
  PagesInt8,
  PagesUInt8,
  PagesInt16,
  PagesUInt16,
  PagesInt32,
  PagesUInt32,
  PagesInt64,
  PagesUInt64,
  PagesFloat32,
  PagesFloat64
}

table Column {
  data: Pages (required);
  numentries: uint64 (required);
  page_extremes: [Extreme];
}

table Chunk {
  columns: [Column] (required);
  numentries: uint64 (required);
}

table Ntuple {
  identifier: string (key);
  numentries: uint64 (required);
  columns: [string] (required);
  chunks: [Chunk] (required);
  unbinned_stats: [DistributionStats];
  title: string;
  metadata: Metadata;
  decoration: Decoration;
}

///////////////////////////////////////////////// Book

table Book {
  identifer: string (key);
  histograms: [Histogram];
  ntuples: [Ntuple];
  books: [Book];
}

file_extension "hist";
file_identifier "hist";
root_type Book;
