namespace histos.generated;

///////////////////////////////////////////////// Decoration

enum DecorationLanguage: int {
  deco_inline = 0,
  deco_css = 1,
  deco_vega = 2,
  deco_root_json = 3
}

table Decoration {
  language: DecorationLanguage;
  specification: string;
}

///////////////////////////////////////////////// Metadata

// ...


///////////////////////////////////////////////// Histogram

enum ErrorMethod: byte {
  frac_normal = 0,
  frac_clopper_pearson = 1,
  frac_wilson = 2,
  frac_agresti_coull = 3,
  frac_feldman_cousins = 4,
  frac_jeffrey = 5,
  frac_bayesian_uniform = 6
}

table FractionBinning {
  error_method: ErrorMethod;
}

table IntegerBinning {
  min: long;   // assumed to be inclusive (if not, change its value!)
  max: long;
  has_underflow: bool = true;
  has_overflow: bool = true;
}

table RealInterval {
  low: double;
  high: double;
  low_inclusive: bool = true;
  high_inclusive: bool = false;
}

enum NonRealMapping: byte {
  missing = 0,
  in_underflow = 1,
  in_overflow = 2,
  in_nanflow = 3
}

table RealOverflow {
  has_underflow: bool = true;
  has_overflow: bool = true;
  has_nanflow: bool = true;
  minf_mapping: NonRealMapping = in_underflow;
  pinf_mapping: NonRealMapping = in_underflow;
  nan_mapping: NonRealMapping = in_nanflow;
}

table RegularBinning {
  num: ulong;
  interval: RealInterval (required);
  overflow: RealOverflow;
  circular: bool = false;
}

table TicTacToeOverflowBinning {
  numx: ulong;
  numy: ulong;
  x: RealInterval (required);
  y: RealInterval (required);
  overflow: RealOverflow (required);
}

// https://www.redblobgames.com/grids/hexagons
enum HexagonalCoordinates: byte {
  offset = 0,
  doubled_offset = 1,
  cube_xy = 2,
  cube_yz = 3,
  cube_xz = 4
}

table HexagonalBinning {
  q: IntegerBinning (required);
  r: IntegerBinning (required);
  coordinates: HexagonalCoordinates = offset;
  originx: double = 0.0;    // x coordinate of (q, r) == (0, 0)
  originy: double = 0.0;    // y coordinate of (q, r) == (0, 0)
}

table VariableBinning {
  intervals: [RealInterval] (required);
  overflow: RealOverflow;
}

table CategoryBinning {
  categories: [string] (required);
}

table SparseRegularBinning {
  bin_width: double;
  origin: double = 0.0;
  nanflow: bool = true;
}

union Binning {
  FractionBinning,
  IntegerBinning,
  RegularBinning,
  TicTacToeOverflowBinning,
  HexagonalBinning,
  VariableBinning,
  CategoryBinning,
  SparseRegularBinning
}

table Region {
  expressions: [string];      // predicates to apply
}

table Slice {
  expression: string;         // expression to slice
  binning: Binning (required);
}

table Systematic {
  p: double = 0.6826894921370859;    // +1 sigma
  category: string;                  // optional
}

table Variation {
  expressions: [string];      // assignments in this block
  systematic: [Systematic];
}

table Multiplier {
  identifier: string (key);
  sources: [string];          // sources for which this multiplier is valid
  region: Region;
  slice: Slice;
  variations: [Variation];
  multiplier: [Multiplier];
  title: string;
  decoration: Decoration;
}

table Axis {
  binning: Binning;      // note: no binning is allowed
  expression: string;
  title: string;
  decoration: Decoration;
}

table CountInt8 {
  count: [byte] (required);
}

table CountInt16 {
  count: [short] (required);
}

table CountInt32 {
  count: [int] (required);
}

table CountInt64 {
  count: [long] (required);
}

table CountFloat32 {
  count: [float] (required);
}

table CountFloat64 {
  count: [double] (required);
}

union Count {
  CountInt8,
  CountInt16,
  CountInt32,
  CountInt64,
  CountFloat32,
  CountFloat64
}

table WeightedFloat32 {
  sumw: [float] (required);
  sumw2: [float] (required);
  count: Count;   // optional; can use if different from sumw
}

table WeightedFloat64 {
  sumw: [double] (required);
  sumw2: [double] (required);
  count: Count;   // optional; can use if different from sumw
}

union Content {
  CountInt8,
  CountInt16,
  CountInt32,
  CountInt64,
  CountFloat32,
  CountFloat64,
  WeightedFloat32,
  WeightedFloat64
}

table Correlation {
  sumwx: [double] (required);
  sumwxy: [double] (required);   // symmetric matrix: N*(N+1) elements
}

table Extreme {
  min: double;
  max: double;
}

table Moment {
  n: int;
  sumwn: [double] (required);
}

table Quantile {
  p: double;    // 0.0 <= p <= 1.0
  value: [double] (required);
}

table GenericError {
  error: double;
  p: double = 0.6826894921370859;    // +1 sigma
}

table DistributionStats {
  correlation: Correlation;
  extremes: [Extreme];
  moments: [Moment];
  quantiles: [Quantile];
  generic_errors: [GenericError];
}

table Distribution {
  content: Content (required);
  stats: DistributionStats;
}

table Profile {
  expression: string;
  title: string;
  decoration: Decoration;
}

table Histogram {
  lookup: string (key);
  multipliers: [Multiplier];
  axis: [Axis] (required);
  profiles: [Profile];
  distribution: Distribution (required);
  unbinned_stats: [DistributionStats];
  profile_stats: [DistributionStats];
  title: string;
  decoration: Decoration;
}

///////////////////////////////////////////////// Ntuple

// table Ntuple {
// 
// }

///////////////////////////////////////////////// Book

table Book {
  lookup: string (key);
  histograms: [Histogram];
  books: [Book];
}

file_extension "hist";
file_identifier "hist";
root_type Book;
